import {
	HttpStatus,
	Injectable
}                             from '@nestjs/common';
import { SchedulerRegistry }  from '@nestjs/schedule';
import faker                  from '@faker-js/faker';
import {
	CompanyType,
	companyTypeToStr,
	OrderStage,
	OrderStatus,
	TransportStatus,
	UserRole
}                             from '@common/enums';
import {
	DEFAULT_ORDER_STATE,
	GeneratorOptions
}                             from '@common/constants';
import { OpenRouteService }   from '@common/classes/open-route-service';
import {
	IApiResponse,
	ICompany,
	ICompanyGenerateOptions,
	IDriverSimulateData,
	IOrderGenerateOptions,
	IService,
	ISimulateOptions
}                             from '@common/interfaces';
import {
	calculateDistance,
	formatArgs,
	getTranslation,
	isSuccessResponse
}                             from '@common/utils';
import * as generator         from '@common/utils/generators';
import {
	CargoCompany,
	CargoCompanyInn,
	Destination,
	Driver,
	Order,
}                             from '@models/index';
import * as repos             from '@repos/index';
import * as dto               from '@api/dto';
import {
	SocketNotificationGateway
}                             from '@api/notifications';
import CargoCompanyService    from './cargo-company.service';
import CargoCompanyInnService from './cargoinn-company.service';
import DriverService          from './driver.service';
import ImageService           from './image.service';
import OrderService           from './order.service';
import PaymentService         from './payment.service';
import TransportService       from './transport.service';

type TCompany = ICompany & { drivers?: Driver[] };

const TRANSLATIONS = getTranslation('REST', 'GENERATOR');
const { COMPANY_DEFAULTS } = GeneratorOptions;

async function startSimulateCallback(
	driverRepo: repos.DriverRepository,
	orderRepo: repos.OrderRepository,
	destRepo: repos.DestinationRepository,
	gateway: SocketNotificationGateway,
	onFinished: () => void
) {
	const drivers = await driverRepo?.getList({},
		{
			orderStatus:     OrderStatus.PROCESSING,
			isAutogenerated: true
		}
	);
	const driverPromises: Promise<Driver>[] = [];
	const orderPromises: Promise<Order>[] = [];

	for(const driver of drivers) {
		const activeData: IDriverSimulateData[] = driver.data.filter(({ passed }) => !passed);
		let orderTitle = '';
		if(activeData && activeData.length > 0) {
			const simData = activeData[0];
			simData.passed = true;
			driver.data[simData.index] = simData;
			const driverDto: dto.DriverUpdateDto = {
				data:      driver.data,
				latitude:  simData.position[0],
				longitude: simData.position[1]
			};
			if(driver.order) {
				const { order } = driver;
				orderTitle = order.title;
				const destination = order.destination;
				const orderDto: dto.OrderUpdateDto = {};
				if(destination && !destination.fulfilled) {
					const distance = calculateDistance([driverDto.latitude, driverDto.longitude], destination.coordinates);
					if(distance <= .1) {
						destination.fulfilled = true;
						if(order.nextDestination) {
							orderDto.currentPoint = order.nextDestination.point;
						}
						else {
							orderDto.status = OrderStatus.FINISHED;
							orderDto.stage = OrderStage.PAYMENT_FORMED;
							orderDto.onPayment = true;
						}
						await destRepo.update(destination.id, { fulfilled: true });
						orderPromises.push(orderRepo.update(order.id, orderDto));
					}
				}
			}

			gateway.sendDriverNotification(
				{
					id:        driver.id,
					event:     'driver',
					source:    'gen',
					latitude:  driver.latitude,
					longitude: driver.longitude
				},
				{ roles: [UserRole.LOGIST] }
			);
			driverPromises.push(driverRepo.update(driver.id, driverDto));
		}
		else {
			let dist: number = 0, dur: number = 0;
			if(driver.info) {
				const [p1, p2] = driver.info.split('$');
				try {
					dist = Number(p1);
					dur = Number(p2);
				} catch(e) {}
			}
			gateway.sendDriverNotification(
				{
					id:        driver.id,
					event:     'driver',
					source:    `Симуляцию завершена.`,
					message:   `Водитель '${driver.fullName}' завершил симуляцию выполнения заказа '${orderTitle}': расстояние ${dist}, время ${dur}.`,
					latitude:  driver.latitude,
					longitude: driver.longitude
				},
				{ roles: [UserRole.LOGIST] }
			);
			onFinished();
		}
	}

	await Promise.all([
		driverPromises,
		orderPromises
	]);
}

@Injectable()
export default class GeneratorService
	implements IService {
	constructor(
		protected readonly cargoService: CargoCompanyService,
		protected readonly cargoinnService: CargoCompanyInnService,
		protected readonly driverService: DriverService,
		protected readonly orderService: OrderService,
		protected readonly paymentService: PaymentService,
		protected readonly transportService: TransportService,
		protected readonly imageService: ImageService,
		protected readonly socketGateway: SocketNotificationGateway,
		protected readonly schedulerRegistry: SchedulerRegistry
	) {}

	/**
	 * Generates company data depending on args
	 * */
	public async generateCompanies(options?: ICompanyGenerateOptions)
		: Promise<IApiResponse<TCompany[]>> {
		if(!!options?.reset) {
			await this.cargoService.deleteAll({ isAutogenerated: true });
			await this.cargoinnService.deleteAll({ isAutogenerated: true });
		}

		const imageWidth = 500, imageHeight = 500;
		const data = await generator.generateCompanies(options ?? COMPANY_DEFAULTS);
		const companies: TCompany[] = [];

		for(const companyData of data) {
			const { company: companyDto, payment } = companyData;
			let company: TCompany;
			let cargoId: string = null,
				cargoinnId: string = null;

			let apiRes: IApiResponse<any>;
			if(companyDto.type === CompanyType.ORG) {
				apiRes = await this.cargoService.create(companyDto as dto.CompanyCreateDto);
				if(apiRes.data) {
					cargoId = apiRes.data.id;
					company = apiRes.data;
				}
			}
			else {
				apiRes = await this.cargoinnService.create(companyDto as dto.CompanyInnCreateDto);
				if(apiRes.data) {
					cargoinnId = apiRes.data.id;
					company = apiRes.data;
				}
			}

			if(!apiRes.data) {
				return apiRes;
			}

			payment.cargoId = cargoId;
			payment.cargoinnId = cargoinnId;
			if(company)
				await this.paymentService.create(payment);

			const {
				driver:     driverDto,
				transports: transportDtos
			} = await generator.generateDriver(company, (options ?? COMPANY_DEFAULTS).driver);
			const driverResponse = await this.driverService.create(driverDto);

			if(isSuccessResponse(driverResponse)) {
				const { data: driver } = driverResponse;
				for(let index = 0; index < transportDtos.length; ++index) {
					transportDtos[index].cargoId = cargoId;
					transportDtos[index].cargoinnId = cargoinnId;
					transportDtos[index].driverId = driver.id;
					if(index == 0)
						transportDtos[index].status = TransportStatus.ACTIVE;
					const transportResponse = await this.transportService.create(transportDtos[index]);
					if(isSuccessResponse(transportResponse)) {
						const { data: transport } = transportResponse;
						await Promise.all(
							Array.from(Array(5))
									 .map(() => this.imageService.create(
										 {
											 transportId: transport.id,
											 cargoId:     transport.cargoId,
											 cargoinnId:  transport.cargoinnId,
											 url:         faker.image.transport(imageWidth, imageHeight, true)
										 }
									 ))
						);
					}
				}

				if(!company.drivers)
					company.drivers = [driver];
				else
					company.drivers.push(driver);
			}

			companies.push(company);
		}

		const message = formatArgs(
			TRANSLATIONS['COMPANY'],
			companies?.length,
			companies.map(c => companyTypeToStr(c.type)).join(', ')
		);

		return {
			statusCode: 201,
			data:       companies,
			message
		};
	}

	public async generateOrders(options?: IOrderGenerateOptions) {
		if(options.reset)
			await this.orderService.deleteAll({ isAutogenerated: true });

		const orderDtos = await generator.generateOrders(options);
		const orders: Array<Order> = await Promise.all(
			orderDtos.map(
				async dto => {
					const destinations = dto.destinations;
					dto.destinations = [];

					const apiResponse = await this.orderService.create(dto);
					if(isSuccessResponse(apiResponse)) {
						const { data: order } = apiResponse;

						if(!order.destinations) order.destinations = [];

						for(const destination of destinations) {
							destination.orderId = order.id;
							const dest = await Destination.create(destination);
							order.destinations.push(dest);
						}
						return order;
					}
					return null;
				}
			)
		);
		const message = formatArgs(TRANSLATIONS['ORDER'], orders?.length);
		return {
			statusCode: 201,
			data:       orders,
			message
		};
	}

	public async generateSimulation(options: ISimulateOptions)
		: Promise<IApiResponse<any>> {
		let drivers: Driver[];
		let orders: Order[];

		options.company.count = options.order.count = options.count;
		options.company.reset = options.order.reset = options.reset;

		const driverPromises: Array<Promise<IApiResponse<Driver>>> = [];
		const orderPromises: Array<Promise<IApiResponse<Order>>> = [];

		if(options.reset) {
			await this.resetGeneratedData();
		}

		options.company.count = options.count;
		options.company.reset = options.reset;

		const companyGenResponse = await this.generateCompanies(options.company);

		if(isSuccessResponse(companyGenResponse)) {
			const companies = companyGenResponse.data as (CargoCompany | CargoCompanyInn)[];
			drivers = companies.flatMap(c => c.drivers);
		}
		else {
			return {
				statusCode: HttpStatus.INTERNAL_SERVER_ERROR,
				data:       await this.resetGeneratedData()
			};
		}

		options.order.count = options.count;
		options.order.reset = options.reset;

		const orderGenResponse = await this.generateOrders(options.order);

		if(isSuccessResponse(orderGenResponse)) {
			orders = orderGenResponse.data;
		}
		else {
			return {
				statusCode: HttpStatus.INTERNAL_SERVER_ERROR,
				data:       await this.resetGeneratedData()
			};
		}

		const ors = new OpenRouteService();
		const driverRepo = new repos.DriverRepository({ log: false });
		const orderRepo = new repos.OrderRepository({ log: false });
		const destRepo = new repos.DestinationRepository({ log: false });

		while(drivers.length > 0) {
			const driver: Driver = drivers.pop();
			const order: Order = orders.pop();

			orderPromises.push(
				this.orderService.update(
					order.id,
					{
						driverId:     driver.id,
						cargoId:      driver.cargoId,
						cargoinnId:   driver.cargoinnId,
						status:       OrderStatus.PROCESSING,
						stage:        OrderStage.SIGNED_DRIVER,
						execState:    DEFAULT_ORDER_STATE,
						currentPoint: 'A',
						isFree:       false,
						isOpen:       false,
						isCanceled:   false,
						hasProblem:   false
					}
				)
			);

			const destinationPos: [number, number][] = order.destinations.map(d => d.coordinates);
			const positions = (await ors.fetch(
				[driver.asTuplePosition(), ...destinationPos],
				{
					elevation:    false,
					instructions: false,
					radiuses:     [5000],
					units:        'km',
					options:      {
						avoid_borders: "none"
					},
					language:     'ru'
				}
			)).positions;
			const distance = ors.distance;
			const duration = ors.duration;
			const simulateData: IDriverSimulateData[] = positions.map((position, index) => ({
				index,
				passed: false,
				position
			}));

			driverPromises.push(this.driverService.update(driver.id, {
				data: simulateData,
				info: `${distance}$${duration}`
			}));
		}

		await Promise.all([
			orderPromises,
			driverPromises
		]);

		const onFinished = () => this.stopSimulation('simulate', { reset: false });

		this.startInterval(
			'simulate',
			options.interval,
			() => startSimulateCallback(driverRepo, orderRepo, destRepo, this.socketGateway, onFinished)
		);

		return {
			statusCode: HttpStatus.OK
		};
	}

	public async stopSimulation(name: string = 'simulate', options: Pick<ISimulateOptions, 'reset'> = { reset: true }) {
		this.deleteInterval(name);

		if(options.reset) {
			return {
				statusCode: HttpStatus.OK,
				data:       await this.resetGeneratedData()
			};
		}

		return {
			statusCode: HttpStatus.OK
		};
	}

	private async resetGeneratedData() {
		const cond = { isAutogenerated: true };
		const cargoDeleteResponse = await this.cargoService.deleteAll(cond);
		const cargoInnDeleteResponse = await this.cargoinnService.deleteAll(cond);
		const orderDeleteResponse = await this.orderService.deleteAll(cond);

		return { cargoDeleteResponse, cargoInnDeleteResponse, orderDeleteResponse };
	};

	private startInterval(name: string, interval: number, handler: TimerHandler) {
		this.deleteInterval(name);

		const timer = setInterval(handler, interval * 1000);
		this.schedulerRegistry.addInterval(name, timer);
	}

	private deleteInterval(name: string) {
		try {
			if(this.schedulerRegistry.doesExist("interval", name)) {
				this.schedulerRegistry.deleteInterval(name);
			}
		} catch(e) {
			console.error(e);
		}
	}
}
